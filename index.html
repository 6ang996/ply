<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>ply by wkz</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>ply</h1>
        <h2>Dynamic Tracing in Linux</h2>

        <section id="downloads">
          <a href="https://github.com/wkz/ply/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/wkz/ply/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/wkz/ply" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h2>

<p><code>ply</code> compiles ply-scripts into <a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">EBPF</a> programs that can be
attached to kprobes in the kernel. The scripting language borrows
heavily from <a href="http://dtrace.org/blogs/about/">Dtrace</a>, but is much more limited in scope.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h2>

<h3>
<a id="syscall-count" class="anchor" href="#syscall-count" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Syscall Count</h3>

<pre><code>#!/usr/bin/env ply

kprobe:SyS_*
{
    $syscalls[func].count()
}
</code></pre>

<p>This probe will be attached to all functions whose name starts with
<code>SYS_</code>, i.e. all syscalls. On each syscall, the probe will fire and
index into the user-defined map <code>$syscalls</code> using the built-in
variable <code>func</code> as the key and bump a counter.</p>

<p><code>ply</code> will compile the script, attach it to the matching probes and
start collecting data. On exit, <code>ply</code> will dump the value of all
user-defined variables and maps:</p>

<pre><code>wkz@wkz-box:~$ sudo syscall-count.ply
331 probes active
^Cde-activating probes

$syscalls:
sys_mprotect                   1
sys_readv                      1
sys_newlstat                   1
sys_access                     2
sys_bind                       3
sys_getsockname                3
sys_rt_sigaction               4
sys_ftruncate                  4
sys_unlink                     4
sys_pselect6                   4
sys_timerfd_settime            4
sys_dup                        5
sys_fdatasync                  5
sys_lseek                     17
sys_inotify_add_watch         21
sys_newstat                   24
sys_recvfrom                  31
sys_connect                   33
sys_socket                    36
sys_getsockopt                42
sys_epoll_ctl                 58
sys_pread64                   66
sys_openat                    67
sys_setsockopt                85
sys_newuname                 112
sys_getdents                 136
sys_timer_settime            159
sys_pwrite64                 172
sys_rt_sigprocmask           380
sys_clock_gettime            407
sys_nanosleep               1183
sys_newfstat                1657
sys_open                    1663
sys_close                   1899
sys_madvise                 2251
sys_sendmsg                 3980
sys_sendto                  4024
sys_fcntl                   6534
sys_ppoll                   7436
sys_mmap                   10801
sys_setitimer              14201
sys_select                 14624
sys_munmap                 14778
sys_mmap_pgoff             14887
sys_epoll_wait             14898
sys_writev                 19516
sys_write                  22644
sys_read                   28700
sys_poll                   53401
sys_futex                  78401
sys_ioctl                 146141
sys_recvmsg               181933
</code></pre>

<h3>
<a id="distributions" class="anchor" href="#distributions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Distributions</h3>

<pre><code>#!/usr/bin/env ply

kprobe:SyS_read
{
    $sizes.quantize(arg(2))
}
</code></pre>

<p>This example shows a very simple script that instruments the <code>read(2)</code>
syscall and records the distribution of the <code>size</code> argument,
i.e. argument 2 (zero indexed), into the user-defined variable
<code>$sizes</code>.</p>

<pre><code>wkz@wkz-box:~$ sudo read-dist.ply
1 probe active
^Cde-activating probes

$sizes:
[   0,    1]        2089
[   2,    4)         434
[   4,    8)        6334
[   8,   16)        9738
[  16,   32)        1645
[  32,   64)          16
[  64,  128)          24
[ 128,  256)          63
[ 256,  512)         102
[ 512,   1k)         200
[  1k,   2k)         433
[  2k,   4k)         750
[  4k,   8k)        1492
[  8k,  16k)        1157
[ 16k,  32k)        5703
[ 32k,  64k)          26
[ 64k, 128k)          48
</code></pre>

<h2>
<a id="motivation" class="anchor" href="#motivation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Motivation</h2>

<p>The intention of <code>ply</code> is to be a lightweight alternative to
<a href="https://github.com/iovisor/bcc">bcc</a>. Both in terms of dependencies and in usage. <code>bcc</code> requires
LLVM which rules out many embedded platforms. <code>ply</code> has no run-time
dependencies and only depends on flex and bison to build. By using the
<a href="http://c2.com/cgi/wiki?LittleLanguage">Little Language</a> approach, scripts are easy to write and
modify. C, while being an extremely powerful and elegant language does
not offer the same exploratory feeling as say <code>awk</code>, which <code>ply</code> more
closely resembles.</p>
      </section>
    </div>

    
  </body>
</html>
