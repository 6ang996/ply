{"name":"ply","tagline":"Dynamic Tracing in Linux","body":"## Introduction\r\n\r\n`ply` compiles ply-scripts into [EBPF][1] programs that can be\r\nattached to kprobes in the kernel. The scripting language borrows\r\nheavily from [Dtrace][2], but is much more limited in scope.\r\n\r\n## Examples\r\n\r\n### Syscall Count\r\n\r\n```\r\n#!/usr/bin/env ply\r\n\r\nkprobe:SyS_*\r\n{\r\n\t$syscalls[func].count()\r\n}\r\n```\r\n\r\nThis probe will be attached to all functions whose name starts with\r\n`SYS_`, i.e. all syscalls. On each syscall, the probe will fire and\r\nindex into the user-defined map `$syscalls` using the built-in\r\nvariable `func` as the key and bump a counter.\r\n\r\n`ply` will compile the script, attach it to the matching probes and\r\nstart collecting data. On exit, `ply` will dump the values of all\r\nuser-defined variables and maps:\r\n\r\n```\r\nwkz@wkz-box:~$ sudo syscall-count.ply\r\n331 probes active\r\n^Cde-activating probes\r\n\r\n$syscalls:\r\nsys_mprotect        \t       1\r\nsys_readv           \t       1\r\nsys_newlstat        \t       1\r\nsys_access          \t       2\r\nsys_bind            \t       3\r\nsys_getsockname     \t       3\r\nsys_rt_sigaction    \t       4\r\nsys_ftruncate       \t       4\r\nsys_unlink          \t       4\r\nsys_pselect6        \t       4\r\nsys_timerfd_settime \t       4\r\nsys_dup             \t       5\r\nsys_fdatasync       \t       5\r\nsys_lseek           \t      17\r\nsys_inotify_add_watch\t      21\r\nsys_newstat         \t      24\r\nsys_recvfrom        \t      31\r\nsys_connect         \t      33\r\nsys_socket          \t      36\r\nsys_getsockopt      \t      42\r\nsys_epoll_ctl       \t      58\r\nsys_pread64         \t      66\r\nsys_openat          \t      67\r\nsys_setsockopt      \t      85\r\nsys_newuname        \t     112\r\nsys_getdents        \t     136\r\nsys_timer_settime   \t     159\r\nsys_pwrite64        \t     172\r\nsys_rt_sigprocmask  \t     380\r\nsys_clock_gettime   \t     407\r\nsys_nanosleep       \t    1183\r\nsys_newfstat        \t    1657\r\nsys_open            \t    1663\r\nsys_close           \t    1899\r\nsys_madvise         \t    2251\r\nsys_sendmsg         \t    3980\r\nsys_sendto          \t    4024\r\nsys_fcntl           \t    6534\r\nsys_ppoll           \t    7436\r\nsys_mmap            \t   10801\r\nsys_setitimer       \t   14201\r\nsys_select          \t   14624\r\nsys_munmap          \t   14778\r\nsys_mmap_pgoff      \t   14887\r\nsys_epoll_wait      \t   14898\r\nsys_writev          \t   19516\r\nsys_write           \t   22644\r\nsys_read            \t   28700\r\nsys_poll            \t   53401\r\nsys_futex           \t   78401\r\nsys_ioctl           \t  146141\r\nsys_recvmsg         \t  181933\r\n```\r\n\r\n### Distributions\r\n\r\n```\r\n#!/usr/bin/env ply\r\n\r\nkprobe:SyS_read\r\n{\r\n\t$sizes.quantize(arg(2))\r\n}\r\n```\r\n\r\nThis example shows a very simple script that instruments the `read(2)`\r\nsyscall and records the distribution of the `size` argument,\r\ni.e. argument 2 (zero indexed), into the user-defined variable\r\n`$sizes`.\r\n\r\n```\r\nwkz@wkz-box:~$ sudo read-dist.ply\r\n1 probe active\r\n^Cde-activating probes\r\n\r\n$sizes:\r\n[   0,    1]\t    2089\r\n[   2,    4)\t     434\r\n[   4,    8)\t    6334\r\n[   8,   16)\t    9738\r\n[  16,   32)\t    1645\r\n[  32,   64)\t      16\r\n[  64,  128)\t      24\r\n[ 128,  256)\t      63\r\n[ 256,  512)\t     102\r\n[ 512,   1k)\t     200\r\n[  1k,   2k)\t     433\r\n[  2k,   4k)\t     750\r\n[  4k,   8k)\t    1492\r\n[  8k,  16k)\t    1157\r\n[ 16k,  32k)\t    5703\r\n[ 32k,  64k)\t      26\r\n[ 64k, 128k)\t      48\r\n```\r\n\r\n## Motivation\r\n\r\nThe intention of `ply` is to be a lightweight alternative to\r\n[bcc][3]. Both in terms of dependencies and in usage. `bcc` requires\r\nLLVM which rules out many embedded platforms. `ply` has no run-time\r\ndependencies and only depends on flex and bison to build. By using the\r\n[Little Language][4] approach, scripts are easy to write and\r\nmodify. C, while being an extremely powerful and elegant language does\r\nnot offer the same exploratory feeling as say `awk`, which `ply` more\r\nclosely resembles.\r\n\r\n\r\n[1]: https://www.kernel.org/doc/Documentation/networking/filter.txt\r\n[2]: http://dtrace.org/blogs/about/\r\n[3]: https://github.com/iovisor/bcc\r\n[4]: http://c2.com/cgi/wiki?LittleLanguage","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}